/**
;;;;;G3999999999999hGGG&&&&&&G999999999999999999999999999999999999999999999999999hh93X255SissrrrrrsssiiiSSSSS5
;;sh339999999999999GGGG&&&&&&&h399999999999999999999999999999999999999999999999939h93X255SissrrrrsssiiSS555552
h39399999999999999GGGG&&&&&&&&G999999999999999999999999999999999999999999999999993h93X255SissrrrrssiiSS55522XX
99999999999999999hhGGG&&&&&&&&&G99999999999999999999999999999999999999999999999999993X255SissrrrsssiiSS552XXXX
99999999999999999hhGGG&&&&&&&&&&999999999999999999999999999999999999999999999999999h3X255SissrrrsssiSS5522XX33
9999999999999999GhhGGG&&&&&&&&&&h99999999999999999999999999999999999999999999999993h3X255SissrrrsssiiS5522X333
9999999999999999hhhGGG&&&&&&&&&&G9999999999999999999999999999999999999999999999999993X255SissrrrsssiSS552XX333
999999999999999hhhhGGGGGGGGGGGGG&h99999999999999999999999999999999999999999999999993hX225SisssrsssiiSS522XX333
99999999999999hhhhhhGGGGGGGGGGGGGG99999999999999999999999999999999999999999999999999h3X25SiisssssiiSS5522XX333
99999999999999hhhhhhhGGhGGGGGGGGGGh399999999999999999999999999999999999999999999999933X225SSiiiiiiSS5522XX3333
9999999999993GGGGGhhhhhhhhhhhhhGGGG99999999999999999999999999999999999999999999999999G3X255SSSSSSSS5522XXX3333
99999999999H&&AH&Ghhhhh9h9hhhhhhhhG99999999999999999999999999999999999999999999999999h33X2255555552222XXXX3333
999999999999H&&&&&&H3999999999hhhhhh39999999999999999999999999999999999999999999999999933XX22222222XXXXXX33333
99999999999GH&&&&&Hrrs2B9999999hhhhh99999999999999999999999999999999999999999999999993h9933XXXXXXXXXX333333333
99999999999HHH&&&&HrrrrrssB39999hhhGh9999999999999999999999999999999999999999999999999hh9999333333333333333333
9999999999G&&&H&&&HsrrrrrrsrrB99hhhGG99999999999999999999999999999999999999999999999999hhhhhhhhhhhhhhh9hhh9h99
999999999999999B&&Hrrrrrrrrrrrs;BhhGG93999999999999999999999999999999999999999999999999GGGGGGGGGGGGGGGGGGGGGGG
999999999G333333H&HsrrrrrrrrrrrrrsrBhG9999999999999999999999999999999999999999999999999G&&&&&&&&&&&&&&&&&&&HBr
99999999h33333333H&rrrrrrrrrrrrrrrrrsHG9999999999999999999999999999999999999999999999999&&&&&&&&&&&&&&&BBrssrr
999999393333333333BBrrrrrrrrrrrrrrrrrsrsH33999999999999999999999999999999999999999999999G&&&&&&&&&&AArrrsrrrrr
9999993G33333333993BrrrrrrrrrrrrrrrrrrrrrrH399999999999999999999999999999999999999999999G&&&&&G&Brrsrrrrrrrrrr
99999993333333399999HsrrrrrrrrrrrrrrrrrrrrssA99999999999999999999999999999999999999999999&&GH;ssrrrrrrrrrrrrrr
999999G333333333999hhBrsrrrrrrrrrrrrrrrrrrrrssB99999999999999999999999999999999999999993AHrsrrrrrrrrrrrrrrrrrr
99999933333333999hhhGGBrrrrrrrrrrrrrrrrrrrrrrrrrH999999999999999999999999999999999999Hrssrrrrrrrrrrrrrrrrrrrrr
99999G33333333999hhhGGGHsrrrrrrrrrrrrrrrrrrrrrrrs;3393339AHHBHHHA5rr;rrrrrrrsHHHHHHsrsrrrrrrrrrrrrrrrrrrrrrrrr
9999h933333333999hhGGG&GHrrrrrrrrrrrrrrrrrrrrrrrrssrsrrrssrrrrrrrrrrrrrrrrrrrrrrsrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
9999999333333999hhhGGG&&G&;rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
939h99999999999hhhGGGG&&&&&Bsrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
999hhhhhhhhhhhhhGGGGGG&&&&&&Hrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
99hGGGGGGGGGGGGGGGGGG&&&&&&&&&HsrrrrrrsrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrsrA3
99&&&&&&&&&&&&&&&&&&&&&&&&&&&&A&Srrrsi&rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrsss&33
9h&&&&&&&&&&&&&&&&&&&&&&&&&&&&&AABrrHrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrssrrrrrrrM3333
h&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&AAArrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrsHssrrH3993333
G&&&&AAAAAAAAAA&&&&&&&&&&&&&&&&&&&rsrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrBHhh9999999
&&&AAAAAAAAAAAAAA&&&&&&&&&&&&&&&&HrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrsAhhhh99999
&&AAAAAAAAAAAAAAAA&&&&&&&&GG&&&&Hrrrrrrrrrrrsrrrsrsrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrssrrrrrrrrrrrrrrr;Ahhhh9999
AAAAAAAHHHHHHHHAAAA&&&&&&GGGGGGG;srrrrrrrrrrHs,&&&;srrrrrrrrrrrrrrrrrrrrrrrrrrsH::&&A:srrrrrrrrrrrrrrrhhhhhhhh
AAAAAHHHHHHHHHHAAAAA&&&&&GGGGGGHrrrrrrrrrrr&:   &&&rrrrrrrrrrrrrrrrrrrrrrrrrrrA,   &&&rrrrrrrrrrrrrrrrBhhhhhhh
AAAAHHHHHHHHHHHAAAAA&&&&GGGGGGArrrrrrrrrrrrH&,:G&&&ArrrrrrrrrrrrrrrrrrrrrrrrrsH&,,&&&&rrrrrrrrrrrrrrrsrGGGhhhG
AAAAHHHHHHHHHHHHAAAA&&&&GGGGGGHrrrrrrrrrrrrG&&&&&&&rrrrrrrrrrrrrrrrrrrrrrrrrrrA&&&&&&&rrrrrrrrrrrrrrrrrHGGGGGG
AAAHHHHHHHHHHHHHAAAA&&&&GGGGG&srrrrrrrrrrrrrH&&&&G;rrrrrrrrrrrrrrrrrrrrrrrrrrrrB&&&&A;srrrrrrrrrrrrrrrrrGGGGGG
AAAHHHHHHHHHHHHHAAAA&&&&GGGGGHrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrsrrrrrrrrrrrrrrrrrrrrrrrH&GGGG
AAHHHHHHHHHHHHHHHAAA&&&&GGGG&rrrrrrrrrrrrrrrrrrrrrrrrrrrrrsrHHHrrsrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr&&&&&
AAHHHHHHHHHHHHHHAAAA&&&&GGGhHrrrrsrrrsrrrrrrrrrrrrrrrrrrrrrhA&&&HrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrH&&&&
AAAHHHHHHHHHHHHAAAA&&&&GGGGGrrrs533333rsrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrs233333XrrsrrrrrsrG&GG
AAAAAAAAAAAAAAAAAA&&&&GGGGGBss33XXXXXXX32ssrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrss3XXXXXXXXX3rrrrrrsrHGGG
&&&&AAAAAAAAAA&&&&&&GGGGGhhHr3XXXXXXXXXX3rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr3XXXXXXXXXXX3rrrrrrriGGG
&&&&&&&&&&&&&&&&GGGGGhhhhhhGs3XXXXXXXXXXX3rrrrrrrrrrrrrrrrrssrsrrrrrsrrsrrrrrrrrrrrrrr3XXXXXXXXXXX3rsrrrrrrBhh
GGGGGGGGGGGGGGGGGGhhhhhhhh9;rr3XXXXXXXXX3srrrrrrrrrrrrrrsrs&&ssssssss&rrrrrrrrrrrrrrrr3XXXXXXXXXXX3rrrrrrrsHhh
GGGGGhhhhhhhhhhhhhhhhh999992rrr33XXXX335srrrrrrrrrrrrrrrs99sssssssssssGrrrrrrrrrrrrrrrr3XXXXXXXXX3rrrrrrrrrrh9
hhhhhhhhhh99999999999999999Brrsrrssrsrrrsrrrrrrrrrrrrrrrs&ssssssssssssi&rrrrrrrrrrrrrrrsr3333333rrrrrrrrrrrsH9
hhhh999999999999999933333999rrrrrrrrrrrrrrrrrrrrrrrrrrrrs&sssssssssssss&srrrrrrrrrrrrrrrrssrrrssrrrrrrrrrrrr;3
hh99999333333333333333333333BrrrrrrrrrrrrrrrrrrrrrrrrrrrrrAsssssssssssi&srrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrsB
h9999333333333333333333333333hrrrrrrrrrrrrrrrrrrrrrrrrrrrrri&sssssssss&srrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrsH
hh9999333333333333333333333993rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr;&&&&&srrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrsr
hh9999933333333333333333333999Hsrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrsrsrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
hh99999993333333333333333999999Hrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
hhh99999999999999999999999999hhhHrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
hhhhh999999999999999999999999hhhhHrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
hhhhhhhh99999999999999999hhhhhhhhGrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhGGHrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
hhhGhhhhhhhhhhhhhhhhhhhhhhhhhGGGG;rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
hhhGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
 */
#include "PlayableCharacter.h"


#include "Runtime/Engine/Classes/Engine/Engine.h"
#include "Sound/SoundCue.h"

#include "Network/Game/Thread/GameSocketThread.h"

#include "Network/Packets/ClientToGame/MoveToLocation.h"
#include "Network/Packets/ClientToGame/EnterWorld.h"
#include "Network/Packets/ClientToGame/Action.h"
#include "Network/Packets/ClientToGame/RequestDialog.h"
#include "Network/Packets/ClientToGame/RequestAttack.h"
#include "Network/Packets/ClientToGame/ValidatePosition.h"
#include "Network/Packets/ClientToGame/RequestInventory.h"
#include "Network/Packets/ClientToGame/QuestTalk.h"
#include "Network/Packets/ClientToGame/RotationChanged.h"
#include "Components/SkeletalMeshComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Database/Ability/AbilityTable.h"
#include "Database/Sound/Sound2DTable.h"
#include "UserWidget/Windows/CharacterStatus/BaseCharacterStatusWidget.h"

/**
 * @author Dego1n
 */
APlayableCharacter::APlayableCharacter()
{
	PrimaryActorTick.bCanEverTick = true;
	
	//Создаем SpringArm
	OurCameraSpringArm = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraSpringArm"));
	OurCameraSpringArm->SetupAttachment(RootComponent);
	OurCameraSpringArm->SetRelativeLocationAndRotation(FVector(0.0f, 0.0f, 50.0f), FRotator(-60.0f, 0.0f, 0.0f));
	OurCameraSpringArm->TargetArmLength = 400.f;
	OurCameraSpringArm->bEnableCameraLag = false;
	//OurCameraSpringArm->CameraLagSpeed = 3.0f;
	OurCameraSpringArm->bInheritPitch = false;
	OurCameraSpringArm->bInheritRoll = false;
	OurCameraSpringArm->bInheritYaw = false;
	OurCameraSpringArm->TargetArmLength = 500;

	AudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT("AudioComponent"));
	AudioComponent->SetupAttachment(RootComponent);


	//Создаем камеру и аттачим к SpringArm
	OurCamera = CreateDefaultSubobject<UCameraComponent>(TEXT("GameCamera"));
    OurCamera->SetupAttachment(OurCameraSpringArm, USpringArmComponent::SocketName);

	AutoPossessPlayer = EAutoReceiveInput::Player0;

}

void APlayableCharacter::BeginPlay()
{
	Super::BeginPlay();

	//Показываем курсор
	UGameplayStatics::GetPlayerController(GetWorld(), 0)->bShowMouseCursor = true;

	//Биндим шифт для Action
	InputComponent->BindAction("ShiftAction", IE_Pressed, this, &APlayableCharacter::EventShiftPressed);
	InputComponent->BindAction("ShiftAction", IE_Released, this, &APlayableCharacter::EventShiftReleased);

	//Байнды для разворота камеры
	InputComponent->BindAxis("Turn", this, &APlayableCharacter::CameraTurn);
	InputComponent->BindAxis("LookUp", this, &APlayableCharacter::CameraLookUp);

	//Ивент при нажатии левой кнопки мыши (поиск экшена)
	InputComponent->BindAction("LeftMouseButton", IE_Pressed, this, &APlayableCharacter::EventLeftMouseButton);

	//Вверх/вниз камеры
	InputComponent->BindAction("MouseWheelUp", IE_Pressed, this, &APlayableCharacter::EventMouseWheelUp);
	InputComponent->BindAction("MouseWheelDown", IE_Pressed, this, &APlayableCharacter::EventMouseWheelDown);

	InputComponent->BindAxis("MoveForward", this, &APlayableCharacter::MoveForward);
	InputComponent->BindAxis("MoveRight", this, &APlayableCharacter::MoveRight);

	//I - показать\скрыть инвентарь
	InputComponent->BindAction("ShowInventory", IE_Pressed, this, &APlayableCharacter::ShowInventory);

	//Q - показать\скрыть окно квестов
	InputComponent->BindAction("QuestWindow", IE_Pressed, this, &APlayableCharacter::ShowQuestList);

	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());

	//Интерфейс
	instantiatedInGameInterface = CreateWidget<UBaseInGameInterface>(GetWorld(), wgi->inGameInterface);
	instantiatedInGameInterface->AddToViewport();

	//Чат бокс
	instantiatedChatBoxWidget = CreateWidget<UChatBoxWidget>(GetWorld(), wgi->chatBox);
	instantiatedChatBoxWidget->AddToViewport();

}
void APlayableCharacter::EventShiftPressed()
{
	this->isShiftPressed = true;
}
void APlayableCharacter::EventShiftReleased()
{
	this->isShiftPressed = false;
}
void APlayableCharacter::MoveForward(float AxisValue)
{
	if (GetCharacterMovement() && (GetCharacterMovement()->UpdatedComponent == RootComponent))
	{
		GetCharacterMovement()->AddInputVector(GetActorForwardVector() * AxisValue);
	}
}
void APlayableCharacter::MoveRight(float AxisValue)
{
	if (GetCharacterMovement() && (GetCharacterMovement()->UpdatedComponent == RootComponent))
	{
		GetCharacterMovement()->AddInputVector(GetActorRightVector() * AxisValue);
	}
}


void APlayableCharacter::Turn(float AxisValue)
{
	FRotator NewRotation = GetActorRotation();
	NewRotation.Yaw += AxisValue;
	SetActorRotation(NewRotation);
}

void APlayableCharacter::Tick(float DeltaTime)
{
	if (GetVelocity().Size() > 0 && !isMoving) //Если персонаж начал двигаться - сообщаем серверу
	{
		UpdateMoving(true);
	}
	else if (GetVelocity().Size() <= 0 && isMoving) //Если персонаж перестал двигаться - сообщаем серверу
	{
		UpdateMoving(false); 
	}
	//Если персонаж сейчас двигается - отправляем ValidatePosition на сервер
	//Отправляется 10 раз в скунду
	if(isMoving && this == GameSocketThread::Runnable->character)
	{
		if(validatedLocationTime >= 0.1)
		{
			GameSocketThread::Runnable->SendPacket(new ValidatePosition(GetActorLocation()));
			validatedLocationTime -= 0.1;
		}
		validatedLocationTime += DeltaTime;
	}

	Super::Tick(DeltaTime);
}

void APlayableCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);
}

void APlayableCharacter::InventoryUpdated()
{
	if (instantiatedInventoryWidget == nullptr)
		return;
	//instantiatedInventoryWidget->RemoveFromViewport();
	TArray<UBaseInventorySlot*> slots;
	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());
	//Создаем слоты инвентаря
	for (FInventoryItem item : inventoryItems)
	{
		UBaseInventorySlot* slot = CreateWidget<UBaseInventorySlot>(GetWorld(), wgi->inventorySlot);
		slot->itemId = item.item_id;
		slot->objectId = item.object_id;
		slot->count = item.count;
		slots.Add(slot);

	}

	instantiatedInventoryWidget->inventorySlots = slots;

	instantiatedInventoryWidget->equipInfo = *equipInfo;

	//Сообщаем инвентарю о новых слотах
	instantiatedInventoryWidget->ItemListUpdated();
	//instantiatedInventoryWidget->AddToViewport();
}

void APlayableCharacter::ShowInventory()
{
	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());

	if (instantiatedInventoryWidget != nullptr)
	{
		instantiatedInventoryWidget->RemoveFromViewport();
		instantiatedInventoryWidget = nullptr;
	}
	else
	{
		instantiatedInventoryWidget = CreateWidget<UBaseInventory>(GetWorld(), wgi->inventory);

		//instantiatedInventoryWidget->AddToViewport();
		InventoryUpdated();
	}

}
void APlayableCharacter::ShowQuestList()
{
	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());
	if (instantiatedQuestListWidget != nullptr)
	{
		instantiatedQuestListWidget->RemoveFromViewport();
		instantiatedQuestListWidget = nullptr;
	}
	else
	{
		instantiatedQuestListWidget = CreateWidget<UBaseQuestListWindow>(GetWorld(), wgi->QuestWindowWidget);
		instantiatedQuestListWidget->quests = quests;
		instantiatedQuestListWidget->QuestListUpdated();
		instantiatedQuestListWidget->AddToViewport();
	}
}
void APlayableCharacter::UpdateAbilities(TArray<FAbility> abilities)
{
	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());

	for (FAbility &ability : abilities)
	{
		FAbilityTable row = *(wgi->abilitiesData->FindRow<FAbilityTable>(FName(*FString::FromInt(ability.ability_id)), "", true));
		ability.ability_name = row.name;
		ability.ability_description = row.description;
		ability.ability_mana_cost = row.manaCost;
	}

	characterAbilities = abilities;
}
void APlayableCharacter::ShowBuyList(TMap<FInventoryItem, int32> buyItems, TMap<FInventoryItem, int32> sellItems, int32 currencyId, int32 buylistId)
{
	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());

	if (instantiatedBuyListWidget != nullptr)
	{
		instantiatedBuyListWidget->RemoveFromViewport();
	}
	instantiatedBuyListWidget = CreateWidget<UBaseBuyList>(GetWorld(), wgi->buyListWidget);
	instantiatedBuyListWidget->buyItems = buyItems;
	instantiatedBuyListWidget->sellItems = sellItems;
	instantiatedBuyListWidget->currencyId = currencyId;
	instantiatedBuyListWidget->buylistId = buylistId;
	instantiatedBuyListWidget->AddToViewport();

	if (instantiatedNPCDialogWidget != nullptr)
	{
		instantiatedNPCDialogWidget->RemoveFromViewport();
		instantiatedNPCDialogWidget = nullptr;
	}

}
void APlayableCharacter::UpdateStatusInfo(int32 level, float currentHp, float maxHp, float currentMp, float maxMp, int32 startLevelExperience, int32 currentExperience, int32 experienceToNextLevel)
{
	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());
	
	UBaseCharacterStatusWidget* statusWidget = wgi->characterStatusWidget;
	statusWidget->level = level;
	statusWidget->currentHp = currentHp;
	statusWidget->maxHp = maxHp;
	statusWidget->percentHp = ((currentHp * 100) / maxHp)/100;
	statusWidget->currentMp = currentMp;
	statusWidget->maxMp = maxMp;
	statusWidget->percentMp = ((currentMp * 100) / maxMp)/100;
	statusWidget->startLevelExperience = startLevelExperience;
	statusWidget->currentExperience = currentExperience;
	statusWidget->experienceToNextLevel = statusWidget->experienceToNextLevel;
	float percentage = ((currentExperience - startLevelExperience) * 100.0) / (experienceToNextLevel - startLevelExperience);
	statusWidget->percentExperienceToShow = ((int)(percentage * 100.0))/100.0;
	statusWidget->percentExperience = percentage / 100;

	this->level = level;
	this->currentHp = currentHp;
	this->maxHp = maxHp;
	this->currentMp = currentMp;
	this->maxMp = maxMp;
	this->startLevelExperience = startLevelExperience;
	this->currentExperience = currentExperience;
	this->experienceToNextLevel = experienceToNextLevel;
}
void APlayableCharacter::TargetSelected(AGameActor* actor)
{
	UWorldGameInstance * wgi = Cast<UWorldGameInstance>(GetGameInstance());

	//Если виджет таргета закрыт
	if(instantiatedTargetWidget == nullptr)
	{
		instantiatedTargetWidget = CreateWidget<UTargetWidget>(GetWorld(),wgi->targetWidget);
		instantiatedTargetWidget->AddToViewport();
	}

	//Обновляем информацию виджета
	instantiatedTargetWidget->actorName = actor->name;
	instantiatedTargetWidget->hpPercentage = actor->currentHp / actor->maxHp;

	//Обновляем цель
	target = actor;

}
void APlayableCharacter::CharacterInfoWidget(bool update)
{
	if (instantiatedActorInfoWidget == nullptr && update)
	{
		return;
	}

	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());
	if (instantiatedActorInfoWidget == nullptr)
	{
		instantiatedActorInfoWidget = CreateWidget<UBaseActorInfoWidget>(GetWorld(), wgi->actorInfoWidget);
		instantiatedActorInfoWidget->AddToViewport();
	}
	else if (!update)
	{
		CloseCharacterInfoWidget();
		return;
	}
	instantiatedActorInfoWidget->name = name;
	instantiatedActorInfoWidget->className = "Not Implemented";
	instantiatedActorInfoWidget->level = level;

	instantiatedActorInfoWidget->currentHp = currentHp;
	instantiatedActorInfoWidget->maxHp = maxHp;
	instantiatedActorInfoWidget->percentHp = ((currentHp * 100) / maxHp) / 100;
	instantiatedActorInfoWidget->currentMp = currentMp;
	instantiatedActorInfoWidget->maxMp = maxMp;
	instantiatedActorInfoWidget->percentMp = ((currentMp * 100) / maxMp) / 100;
	instantiatedActorInfoWidget->currentExperience = currentExperience;
	instantiatedActorInfoWidget->startLevelExperience = startLevelExperience;
	instantiatedActorInfoWidget->experienceToNextLevel = experienceToNextLevel;
	float percentage = ((currentExperience - startLevelExperience) * 100.0) / (experienceToNextLevel - startLevelExperience);
	instantiatedActorInfoWidget->percentExperienceToShow = ((int)(percentage * 100.0)) / 100.0;
	instantiatedActorInfoWidget->percentExperience = percentage / 100;
	instantiatedActorInfoWidget->skillPoints = -1;
	instantiatedActorInfoWidget->physAttack = physAttack;
	instantiatedActorInfoWidget->physDefence = physDefence;
	instantiatedActorInfoWidget->physAccuracy = physAccuracy;
	instantiatedActorInfoWidget->physEvasion = physEvasion;
	instantiatedActorInfoWidget->physCritical = physCritical;
	instantiatedActorInfoWidget->attackSpeed = attackSpeed;
	instantiatedActorInfoWidget->moveSpeed = moveSpeed;
	instantiatedActorInfoWidget->magicAttack = -1;
	instantiatedActorInfoWidget->magicDefence = -1;
	instantiatedActorInfoWidget->magicAccuracy = -1;
	instantiatedActorInfoWidget->magicEvasion = -1;
	instantiatedActorInfoWidget->magicCritical = -1;
	instantiatedActorInfoWidget->castingSpeed = -1;
	instantiatedActorInfoWidget->str = str;
	instantiatedActorInfoWidget->con = con;
	instantiatedActorInfoWidget->dex = dex;
	instantiatedActorInfoWidget->_int = _int;
	instantiatedActorInfoWidget->wis = wit;
	instantiatedActorInfoWidget->men = men;
}
void APlayableCharacter::CloseCharacterInfoWidget()
{
	if (instantiatedActorInfoWidget != nullptr)
	{
		instantiatedActorInfoWidget->RemoveFromViewport();
		instantiatedActorInfoWidget = nullptr;
	}
}
void APlayableCharacter::SpecialCharacterInfoWidget(FString name, int32 level, int32 currentHp, int32 maxHp, int32 currentMp, int32 maxMp, int32 pAtk, int32 pDef)
{
	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());
	if (instantiatedActorInfoWidget == nullptr)
	{
		instantiatedActorInfoWidget = CreateWidget<UBaseActorInfoWidget>(GetWorld(), wgi->actorInfoWidget);
		instantiatedActorInfoWidget->AddToViewport();
	}

	if (maxHp == 0) maxHp = 1;
	if (maxMp == 0)	maxMp = 1;

	instantiatedActorInfoWidget->name = name;
	instantiatedActorInfoWidget->className = "Not Implemented";
	instantiatedActorInfoWidget->level = level;
	instantiatedActorInfoWidget->currentHp = currentHp;
	instantiatedActorInfoWidget->maxHp = maxHp;
	instantiatedActorInfoWidget->percentHp = ((currentHp * 100) / maxHp) / 100;
	instantiatedActorInfoWidget->currentMp = currentMp;
	instantiatedActorInfoWidget->maxMp = maxMp;
	instantiatedActorInfoWidget->percentMp = ((currentMp * 100) / maxMp) / 100;
	instantiatedActorInfoWidget->physAttack = pAtk;
	instantiatedActorInfoWidget->physDefence = pDef;
}
void APlayableCharacter::AcquireSkillList(TArray<FAbility> abilities)
{
	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());

	if (instantiatedAcquireSkillListWidget != nullptr && !instantiatedAcquireSkillListWidget->IsInViewport())
	{
		instantiatedAcquireSkillListWidget = nullptr;
	}

	if (instantiatedAcquireSkillListWidget == nullptr)
	{
		instantiatedAcquireSkillListWidget = CreateWidget<UBaseAcquireSkillList>(GetWorld(), wgi->AcquireSkillListWidget);
		instantiatedAcquireSkillListWidget->AddToViewport();
	}

	TArray<UBaseAcquireSkillListSlot*> slots;
	for (FAbility ability : abilities)
	{
		UBaseAcquireSkillListSlot* slot = CreateWidget<UBaseAcquireSkillListSlot>(GetWorld(), wgi->AcquireSkillListSlotWidget);
		FAbilityTable row = *(wgi->abilitiesData->FindRow<FAbilityTable>(FName(*FString::FromInt(ability.ability_id)), "", true));
		ability.ability_name = row.name;
		slot->ability = ability;
		slots.Add(slot);
	}
	instantiatedAcquireSkillListWidget->abilitySlots = slots;
	instantiatedAcquireSkillListWidget->AcquireSkillListUpdated();

}
void APlayableCharacter::updateQuestList(TArray<FQuestProgression> questProgression)
{
	quests = questProgression;
	if (instantiatedQuestListWidget != nullptr)
	{
		instantiatedQuestListWidget->quests = quests;
		instantiatedQuestListWidget->QuestListUpdated();
	}
}
void APlayableCharacter::PlaySound(int32 soundId)
{
	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());
	FSound2DTable soundTable = *(wgi->sounds2DTable->FindRow<FSound2DTable>(FName(*FString::FromInt(soundId)), "", true));
	AudioComponent->SetSound(LoadObject<USoundCue>(NULL, *soundTable.path.ToString()));
	AudioComponent->Play();
}
void APlayableCharacter::TargetUnselected()
{
	UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());

	if (instantiatedTargetWidget != nullptr)
	{
		instantiatedTargetWidget->RemoveFromViewport();
		instantiatedTargetWidget = nullptr;
		target = nullptr;
	}
}

void APlayableCharacter::onLootDataUpdated(AGameActor* actor)
{
	if (instantiatedLootWindow != nullptr && instantiatedLootWindow->IsInViewport() && instantiatedLootWindow->owner == actor)
	{
		TArray<UBaseLootWindowSlot*> slots;
		UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());

		for (LootObjectStruct lootObject : actor->loot)
		{
			UBaseLootWindowSlot* slot = CreateWidget<UBaseLootWindowSlot>(GetWorld(), wgi->lootWindowSlot);
			slot->itemId = lootObject.item_id;
			//TODO: count не хендлится
			slot->objectId = lootObject.object_id; //TODO: получать правильный objectId
			slot->actorObjectId = lootObject.actorId;
			slots.Add(slot);
		}

		instantiatedLootWindow->lootWindowSlots = slots;
		instantiatedLootWindow->SlotsUpdated();
	}
	
}

AGameActor* APlayableCharacter::GetCurrentTarget()
{
	return target;
}

/**
 * Получили от сервера новое сообщение в чат
 */
void APlayableCharacter::ReceivedChatMessage(FString actorName, FString actorMessage)
{
	if(instantiatedChatBoxWidget != nullptr)
	{
		TArray<FString> messagesArray = instantiatedChatBoxWidget->messages;
		messagesArray.Add(actorName + ": "+actorMessage);
		if(messagesArray.Num() > 100)
			messagesArray.RemoveAt(0);
		instantiatedChatBoxWidget->messages = messagesArray;
		FString messages = "";
		for(FString string : messagesArray)
		{
			messages += string;
			messages += LINE_TERMINATOR;
		}
		instantiatedChatBoxWidget->UpdateChatboxMessages(messages);
	}
}

/**
 * Получили от сервера новое системное сообщение в чат
 */
void APlayableCharacter::ReceivedSystemMessage(FString message)
{
	if(instantiatedChatBoxWidget != nullptr)
	{
		TArray<FString> messagesArray = instantiatedChatBoxWidget->messages;
		messagesArray.Add("<SystemMessage>" + message + "</>");
		if(messagesArray.Num() > 100)
			messagesArray.RemoveAt(0);
		instantiatedChatBoxWidget->messages = messagesArray;
		FString messages = "";
		for(FString string : messagesArray)
		{
			messages += string;
			messages += LINE_TERMINATOR;
		}
		instantiatedChatBoxWidget->UpdateChatboxMessages(messages);
	}
}

/**
 * Сервер просит показать диалог
 */
void APlayableCharacter::ShowDialog(FString dialog)
{
	UWorldGameInstance * wgi = Cast<UWorldGameInstance>(GetGameInstance());

	if(instantiatedNPCDialogWidget == nullptr)
	{
		instantiatedNPCDialogWidget = CreateWidget<UNPCDialog>(GetWorld(),wgi->npcDialog);
	}

	instantiatedNPCDialogWidget->UpdateDialog(dialog);
	instantiatedNPCDialogWidget->AddToViewport();
}

/**
 * Закрыть диалог
 */
void APlayableCharacter::CloseDialog()
{
	instantiatedNPCDialogWidget->RemoveFromViewport();
	instantiatedNPCDialogWidget = nullptr;
}

/**
 * Запрос на получения диалога
 */
void APlayableCharacter::GetDialog(int32 objectId, FString dialog)
{
	GameSocketThread::Runnable->SendPacket(new RequestDialog(objectId, dialog));
}

void APlayableCharacter::OnQuestTalk(int32 objectId, int32 questId, FString ref)
{
	GameSocketThread::Runnable->SendPacket(new QuestTalk(objectId, questId, ref));
}

/**
 * Запрос на движение к Location
 */
void APlayableCharacter::RequestMoveToLocation(FVector origin, FVector target)
{
	GameSocketThread::Runnable->SendPacket(new MoveToLocation(origin,target));
}

int32 APlayableCharacter::GetItemAmount(int32 itemId)
{
	for (FInventoryItem item : inventoryItems)
	{
		if (item.item_id == itemId)
		{
			return item.count;
		}
	}
	return 0;
}

void APlayableCharacter::CameraLookUp(float value)
{
	FRotator rotator = OurCameraSpringArm->GetComponentRotation();
	OurCameraSpringArm->SetWorldRotation(FRotator(rotator.Pitch + value,rotator.Yaw,0));
}

void APlayableCharacter::EventLeftMouseButton()
{
	//Ищем таргеты по локации мышки
	TArray<TEnumAsByte<enum EObjectTypeQuery>> queries;
	queries.Add(UEngineTypes::ConvertToObjectType(ECC_WorldStatic));
	queries.Add(UEngineTypes::ConvertToObjectType(ECC_Pawn));

	FHitResult hitResults;
	UGameplayStatics::GetPlayerController(GetWorld(), 0)->GetHitResultUnderCursorForObjects(queries,true,hitResults);

	//Если нашли цель и она AGameActor
	if(hitResults.GetActor() != nullptr && hitResults.GetActor()->GetClass()->IsChildOf(AGameActor::StaticClass()))
	{
		//Вытаскиваем цель
		AGameActor* actorResult = Cast<AGameActor>(hitResults.GetActor());

		if(target == actorResult && !actorResult->isFriendly && !actorResult->isDead && !isShiftPressed) //Если цель NPC, не дружелюбна и не мертва - просим сервер атаковать
		{
			GameSocketThread::Runnable->SendPacket(new RequestAttack());
		}
		else if (actorResult->isDead && !isShiftPressed) //Если цель мертва
		{
			if (actorResult->loot.Num() > 0) //Если есть лут
			{
				UWorldGameInstance* wgi = Cast<UWorldGameInstance>(GetGameInstance());
				instantiatedLootWindow = CreateWidget<UBaseLootWindow>(GetWorld(), wgi->lootWindow);
				instantiatedLootWindow->owner = actorResult;
				instantiatedLootWindow->AddToViewport();

				TArray<UBaseLootWindowSlot*> slots;
				for (LootObjectStruct lootObject : actorResult->loot)
				{
					UBaseLootWindowSlot* slot = CreateWidget<UBaseLootWindowSlot>(GetWorld(), wgi->lootWindowSlot);
					slot->itemId = lootObject.item_id;
					//TODO: count не хендлится
					slot->objectId = lootObject.object_id; //TODO: получать правильный objectId
					slot->actorObjectId = lootObject.actorId;
					slots.Add(slot);
				}

				instantiatedLootWindow->lootWindowSlots = slots;
				instantiatedLootWindow->SlotsUpdated();
			}
		}
		else
		{
			//Отсылаем обычный экшн (например запрос диалога или SetTarget)
			GameSocketThread::Runnable->SendPacket(new Action(actorResult->id, isShiftPressed));
		}
	}
}

void APlayableCharacter::EventMouseWheelUp()
{
	float cameraLength = OurCameraSpringArm->TargetArmLength - 20;

	if(cameraLength >= 100)
		OurCameraSpringArm->TargetArmLength = cameraLength;
}

void APlayableCharacter::EventMouseWheelDown()
{
	float cameraLength = OurCameraSpringArm->TargetArmLength + 20;

	if(cameraLength <= 800)
		OurCameraSpringArm->TargetArmLength = cameraLength;
}

void APlayableCharacter::CameraTurn(float value)
{
	if (value != 0)
	{
		FRotator rotator = OurCameraSpringArm->GetComponentRotation();
		OurCameraSpringArm->SetWorldRotation(FRotator(rotator.Pitch, rotator.Yaw + value, 0));
		FRotator NewRotation = GetActorRotation();
		NewRotation.Yaw += value;

		SetActorRotation(NewRotation);
		GameSocketThread::Runnable->SendPacket(new RotationChanged(rotator.Pitch, rotator.Yaw + value));
	}
}

//TODO: Вообще не помню зачем это
FString APlayableCharacter::GetRaceName(int32 characterRace)
{
	FString raceName;
	switch (characterRace)
	{
		case 0:
			raceName = TEXT("Human");
			break;
		case 1:
			raceName = TEXT("Elf");
			break;
		default:
			raceName = TEXT("???");
			break;
	}

	return raceName;
}

//TODO: Вообще не помню зачем это
FString APlayableCharacter::GetCharacterClassName(int32 characterClass)
{
	FString className;
	switch (characterClass)
	{
	case 0:
		className = TEXT("Fighter");
		break;
	case 1:
		className = TEXT("Mystic");
		break;
	default:
		className = TEXT("???");
		break;
	}

	return className;
}

/**
 * Ивент при начале движения
 */
void APlayableCharacter::OnStartMoving()
{
	validatedLocationTime = 0;
	GameSocketThread::Runnable->SendPacket(new ValidatePosition(GetActorLocation()));
}

/**
 * Ивент при окончании движения
 */
void APlayableCharacter::OnStopMoving()
{
	validatedLocationTime = 0;
	GameSocketThread::Runnable->SendPacket(new ValidatePosition(GetActorLocation(),true));
}

/**
 * Получили от сервера UserInfo
 */
void APlayableCharacter::UserInfoUpdated()
{
	this->UpdateSkeletalMesh();
}
